# ğŸ“˜ ç”Ÿäº§çº§Agentæ¶æ„è®¾è®¡

> **å­¦ä¹ ç›®æ ‡**ï¼šæŒæ¡å¯æ‰©å±•ã€å¯ç»´æŠ¤çš„Agentç³»ç»Ÿæ¶æ„

---

## ğŸ¯ æœ¬æ•™ç¨‹ç›®æ ‡

å®Œæˆæœ¬æ•™ç¨‹åï¼Œä½ å°†èƒ½å¤Ÿï¼š

- âœ… è®¾è®¡åˆ†å±‚Agentæ¶æ„
- âœ… å®ç°å·¥å…·æ³¨å†Œç®¡ç†
- âœ… æ„å»ºAgentåè°ƒå™¨
- âœ… å®ç°é”™è¯¯å¤„ç†ä¸é‡è¯•

---

## ğŸ“š æ¶æ„è®¾è®¡

### ç”Ÿäº§çº§Agentæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Production Agent System                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    Gateway Layer                            â”‚â”‚
â”‚  â”‚   [è®¤è¯] [é™æµ] [æ—¥å¿—] [è¿½è¸ª] [ç›‘æ§]                         â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                  Orchestration Layer                        â”‚â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚â”‚
â”‚  â”‚   â”‚ Task Router  â”‚  â”‚ State Managerâ”‚  â”‚ Error Handlerâ”‚     â”‚â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                              â”‚                                   â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚         â–¼                    â–¼                    â–¼             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Planner   â”‚      â”‚  Executor  â”‚      â”‚  Reviewer  â”‚        â”‚
â”‚  â”‚   Agent    â”‚      â”‚   Agent    â”‚      â”‚   Agent    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚        â”‚                   â”‚                   â”‚                â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                            â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                     Tool Layer                              â”‚â”‚
â”‚  â”‚   [æœç´¢] [è®¡ç®—] [ä»£ç æ‰§è¡Œ] [æ–‡ä»¶æ“ä½œ] [APIè°ƒç”¨] [æ•°æ®åº“]      â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    Memory Layer                             â”‚â”‚
â”‚  â”‚   [çŸ­æœŸè®°å¿†] [é•¿æœŸè®°å¿†] [å‘é‡å­˜å‚¨] [ä¼šè¯ç¼“å­˜]                 â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» æ ¸å¿ƒä»£ç å®ç°

### 1. å·¥å…·æ³¨å†Œç³»ç»Ÿ

```python
from typing import Callable, Any
from dataclasses import dataclass
from enum import Enum

class ToolCategory(Enum):
    SEARCH = "search"
    COMPUTE = "compute"
    FILE = "file"
    API = "api"
    DATABASE = "database"

@dataclass
class ToolDefinition:
    name: str
    description: str
    function: Callable
    category: ToolCategory
    parameters: dict
    required_permissions: list[str] = None

class ToolRegistry:
    """å·¥å…·æ³¨å†Œä¸­å¿ƒ"""
    
    def __init__(self):
        self._tools: dict[str, ToolDefinition] = {}
    
    def register(self, tool: ToolDefinition):
        """æ³¨å†Œå·¥å…·"""
        self._tools[tool.name] = tool
        print(f"âœ… å·¥å…·å·²æ³¨å†Œ: {tool.name}")
    
    def get(self, name: str) -> ToolDefinition:
        """è·å–å·¥å…·"""
        if name not in self._tools:
            raise ValueError(f"å·¥å…·ä¸å­˜åœ¨: {name}")
        return self._tools[name]
    
    def list_tools(self, category: ToolCategory = None) -> list[ToolDefinition]:
        """åˆ—å‡ºå·¥å…·"""
        tools = list(self._tools.values())
        if category:
            tools = [t for t in tools if t.category == category]
        return tools
    
    def to_openai_format(self) -> list[dict]:
        """è½¬æ¢ä¸ºOpenAI toolsæ ¼å¼"""
        return [
            {
                "type": "function",
                "function": {
                    "name": tool.name,
                    "description": tool.description,
                    "parameters": tool.parameters
                }
            }
            for tool in self._tools.values()
        ]

# ä½¿ç”¨è£…é¥°å™¨æ³¨å†Œå·¥å…·
registry = ToolRegistry()

def tool(name: str, category: ToolCategory, description: str, parameters: dict):
    """å·¥å…·æ³¨å†Œè£…é¥°å™¨"""
    def decorator(func: Callable):
        tool_def = ToolDefinition(
            name=name,
            description=description,
            function=func,
            category=category,
            parameters=parameters
        )
        registry.register(tool_def)
        return func
    return decorator

# ç¤ºä¾‹ï¼šæ³¨å†Œæœç´¢å·¥å…·
@tool(
    name="web_search",
    category=ToolCategory.SEARCH,
    description="æœç´¢äº’è”ç½‘è·å–ä¿¡æ¯",
    parameters={
        "type": "object",
        "properties": {
            "query": {"type": "string", "description": "æœç´¢å…³é”®è¯"}
        },
        "required": ["query"]
    }
)
async def web_search(query: str) -> str:
    # å®é™…æœç´¢å®ç°
    return f"æœç´¢ç»“æœ: {query}"
```

### 2. AgentåŸºç±»

```python
from abc import ABC, abstractmethod
from typing import Optional
import asyncio

class BaseAgent(ABC):
    """AgentåŸºç±»"""
    
    def __init__(
        self,
        name: str,
        llm_client,
        tool_registry: ToolRegistry,
        max_iterations: int = 10
    ):
        self.name = name
        self.llm = llm_client
        self.tools = tool_registry
        self.max_iterations = max_iterations
        self.memory: list[dict] = []
    
    @abstractmethod
    async def plan(self, task: str, context: dict) -> list[dict]:
        """åˆ¶å®šæ‰§è¡Œè®¡åˆ’"""
        pass
    
    @abstractmethod
    async def execute(self, plan: list[dict]) -> dict:
        """æ‰§è¡Œè®¡åˆ’"""
        pass
    
    async def run(self, task: str, context: dict = None) -> dict:
        """è¿è¡ŒAgentå®Œæ•´æµç¨‹"""
        context = context or {}
        
        for i in range(self.max_iterations):
            try:
                # 1. è§„åˆ’
                plan = await self.plan(task, context)
                
                # 2. æ‰§è¡Œ
                result = await self.execute(plan)
                
                # 3. æ£€æŸ¥æ˜¯å¦å®Œæˆ
                if result.get("status") == "completed":
                    return result
                
                # 4. æ›´æ–°ä¸Šä¸‹æ–‡
                context.update(result.get("context_updates", {}))
                
            except Exception as e:
                return {
                    "status": "error",
                    "error": str(e),
                    "iteration": i
                }
        
        return {"status": "max_iterations_reached"}
```

### 3. åè°ƒå™¨å®ç°

```python
class AgentOrchestrator:
    """Agentåè°ƒå™¨"""
    
    def __init__(self):
        self.agents: dict[str, BaseAgent] = {}
        self.task_queue = asyncio.Queue()
        self.results: dict[str, dict] = {}
    
    def register_agent(self, agent: BaseAgent):
        """æ³¨å†ŒAgent"""
        self.agents[agent.name] = agent
    
    async def dispatch(self, task: dict) -> dict:
        """åˆ†å‘ä»»åŠ¡"""
        agent_name = task.get("agent")
        
        if agent_name not in self.agents:
            raise ValueError(f"Agentä¸å­˜åœ¨: {agent_name}")
        
        agent = self.agents[agent_name]
        result = await agent.run(
            task=task["description"],
            context=task.get("context", {})
        )
        
        return result
    
    async def run_workflow(self, workflow: list[dict]) -> dict:
        """æ‰§è¡Œå·¥ä½œæµ"""
        context = {}
        results = []
        
        for step in workflow:
            step["context"] = context
            result = await self.dispatch(step)
            results.append(result)
            
            # ä¼ é€’ä¸Šä¸‹æ–‡åˆ°ä¸‹ä¸€æ­¥
            if result.get("status") == "completed":
                context.update(result.get("output", {}))
            else:
                # å¤±è´¥æ—¶ä¸­æ­¢
                return {
                    "status": "workflow_failed",
                    "failed_step": step,
                    "results": results
                }
        
        return {
            "status": "workflow_completed",
            "results": results
        }
```

---

## ğŸ“Š å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£åˆ†å±‚æ¶æ„è®¾è®¡
- [ ] ä¼šå®ç°å·¥å…·æ³¨å†Œç³»ç»Ÿ
- [ ] èƒ½å¤Ÿè®¾è®¡AgentåŸºç±»
- [ ] ç†è§£åè°ƒå™¨æ¨¡å¼

---

## ğŸ¯ ä¸‹ä¸€æ­¥

ç»§ç»­å­¦ä¹ ï¼š[Agentè®°å¿†ç³»ç»Ÿ](./02_memory_system.md)
